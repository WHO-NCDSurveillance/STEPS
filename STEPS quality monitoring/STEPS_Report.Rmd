---
title: "STEPS Survey monitoring report"
#author: "SMR"
date: "`r format(Sys.time(), '%d %B, %Y')`"

output:
  html_document:
    toc: true # table of content true
    toc_float: true
    toc_depth: 3  # upto three depths of headings (specified by #, ## and ###)
    number_sections: false  ## if you want number sections at each table header
    self_contained: yes
    theme: united  # many options for theme, this one is my favorite.
    highlight: tango  # specifies the syntax highlighting style
    css: css.css
---

<link rel="icon" href="favicon.ico" type="image/x-icon">
<img src="logo.png" style="position:absolute;top:0px;right:0px;" />
<div class="watermark"></div>

```{r variables, include=FALSE}
library(askpass)
library(dplyr)
library(DT)
library(ggiraph)
library(ggplot2)
library(httr)
library(kableExtra)
library(lubridate)
library(openxlsx)
library(patchwork)
library(plotly)
library(RColorBrewer)
library(readxl)
library(tidyr)
library(leaflet)
library(geosphere)

country <- "Country Name"
iso <- "ISO"

#onausername <- rstudioapi::showPrompt("Username", "Please enter your username:")
#onapassword <- rstudioapi::askForPassword("Please enter your password:")
# # or
onausername <- "ctradmin" 		#ona username
onapassword <- "31S62L"   		#ona user password

step1_form_id <- "713225"		#numeric STEP1-2 form ID from form url
step3_form_id <- "713235"		#numeric STEP3 form ID from form url
sample_size <- 3000				#survey sample size
hh_per_cluster <- 11			#number of households selected per cluster
country_average_hhsize <-2.6	#expected average eligible household members

```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#knitr::opts_chunk$set(echo=F, warning = F,  fig.width=10, fig.height=10)

```
```{r download or access data, include=FALSE}

######### Download data from ONA

# Function to download and read Excel data from Ona
download_excel_data <- function(form_id, include_labels = FALSE) {
  base_url <- "https://api.ona.io/api/v1/data/"
  options <- ifelse(include_labels, "?include_labels=true&remove_group_name=true", "?remove_group_name=true")
  url <- paste0(base_url, form_id, ".xlsx", options)
  
  #headers <- add_headers(Authorization = paste("Token", api_token))
  response <- GET(url, authenticate(onausername, onapassword, type = "basic"))
  #response <- GET(url, headers)
  if (status_code(response) == 200) {
    temp_file <- tempfile(fileext = ".xlsx")
    writeBin(response$content, temp_file)
    data <- read_excel(temp_file)
    file.remove(temp_file)
    return(data)
  } else {
    stop("Failed to download data: HTTP status ", status_code(response))
  }
}

# Function to create variable dictionary from data frame
create_variable_dictionary <- function(data_df) {
  column_names <- colnames(data_df)
  first_row <- as.character(data_df[1, ])
  variable_info <- data.frame(Code_value = column_names, Label = first_row, stringsAsFactors = FALSE)
  return(variable_info)
}

# Download data for STEPs 1 & 2
data1 <- download_excel_data(step1_form_id)

# Download variable dictionary for STEPs 1 & 2
#data1_df <- download_excel_data(step1_form_id, include_labels = TRUE)
#data1_labels <- create_variable_dictionary(data1_df)

# Download data for STEP 3
data3 <- download_excel_data(step3_form_id)

# Download variable dictionary for STEP 3
#data3_df <- download_excel_data(step3_form_id, include_labels = TRUE)
#data3_labels <- create_variable_dictionary(data3_df)

## all variables to lowercase
colnames(data1) <- tolower(colnames(data1))
colnames(data3) <- tolower(colnames(data3))

# Remove leading underscores from all column names
names(data1) <- gsub("^_", "", names(data1))
names(data3) <- gsub("^_", "", names(data3))

# Replace "n/a" with NA across the entire dataframe
#data1[] <- lapply(data1, function(x) ifelse(x == "n/a", NA, x))
#data3[] <- lapply(data3, function(x) ifelse(x == "n/a", NA, x))

## Save all data files to csv
write.csv(data1, "data1.csv", row.names = FALSE)
write.csv(data3, "data3.csv", row.names = FALSE)

########################################
#data1 <- read.csv("data1.csv")  #
#data3 <- read.csv("data3.csv")  #
########################################
```
<h0>`r country`</h0><br>
The fieldwork for the STEPS survey in `r country` started on  `r min(data1$i4)`. Up to date, `r length(data1$i4)` records for STEP 1 and `r length(data3$i4_3)` records for STEP3 completed interviews have been exported to the central server. Sample size = `r sample_size`.

# Number of records
## Cumulative nr of records
```{r cumulative nr of records by date, echo=FALSE, message=FALSE, warning=FALSE, out.width = "100%"}
########################################
data1 <- read.csv("data1.csv")  #
data3 <- read.csv("data3.csv")  #
########################################

# Convert submission_time to date format
data1$Date <- as.Date(data1$submission_time)
data3$Date <- as.Date(data3$submission_time)

# Aggregate data by date
count_data1 <- data1 %>%
  group_by(Date) %>%
  summarise(varcount1 = n())

count_data3 <- data3 %>%
  group_by(Date) %>%
  summarise(varcount3 = n())

# Full join the datasets by Date
combined_counts <- full_join(count_data1, count_data3, by = "Date") %>%
  replace_na(list(varcount1 = 0, varcount3 = 0)) %>%
  arrange(Date) %>%
  mutate(CumulativeVarcount1 = cumsum(varcount1),
         CumulativeVarcount3 = cumsum(varcount3))

# Determine the x-axis breaks dynamically based on the range of dates
date_range <- as.numeric(difftime(max(combined_counts$Date), min(combined_counts$Date), units = "days"))
breaks_width <- if (date_range > 30) "1 month" else if (date_range > 7) "1 week" else "1 day"

# Plot
ggplot(combined_counts, aes(x = Date)) +
  geom_area(aes(y = CumulativeVarcount1, fill = "STEP 1"), alpha = 0.3, color = "#31a354") +
  geom_area(aes(y = CumulativeVarcount3, fill = "STEP 3"), alpha = 0.3, color = "#2c7fb8") +
  geom_vline(xintercept = seq(from = min(combined_counts$Date), to = max(combined_counts$Date), by = "1 week"),
             color = "white", linetype = "dashed") +
  scale_x_date(date_breaks = breaks_width, date_labels = "%d-%b-%y") +
  labs(title = "", x = "", y = "# of records") +
  guides(fill = guide_legend(title = NULL)) +
  theme_minimal() +
  scale_fill_manual(values = c("STEP 1" = "#31a354", "STEP 3" = "#2c7fb8")) +
  theme(
    legend.position = c(0.9, 0.1),
    legend.justification = c(0.9, 0.1),
    legend.direction = "horizontal",
    #legend.background = element_rect(fill = "white", colour = NA),
    legend.key.size = unit(0.4, "cm"),  # Smaller legend key
    legend.text = element_text(size = 8),  # Smaller text size
    legend.margin = margin(0, 0, 0, 0)  # Reduced margin for compactness
  )
```

<br>
<br>

## Map

```{r map, echo=FALSE, message=FALSE, warning=FALSE, out.width = "100%"}

########################################
data1 <- read.csv("data1.csv")
########################################

hhmap <- leaflet(data = data1) %>%
  addTiles() %>%  # Add default OpenStreetMap tiles
  addCircleMarkers(lng = ~geopoint_longitude, lat = ~geopoint_latitude,
                   radius = 3,
                   color = '#FF5733',
                   fillOpacity = 0.7,
                   stroke = FALSE,
                   popup = ~paste("Device ID:", device_id,"<br>QR:", qr1))

hhmap
```

<br>
<br>

## Records by Age and Sex
```{r records by age and sex, echo=FALSE, message=FALSE, warning=FALSE, out.width = "100%"}
data1 <- read.csv("data1.csv")

data1 <- data1 %>%
  mutate(sex = case_when(
    c1 == 1 ~ "Males",
    c1 == 2 ~ "Females",
    TRUE ~ NA_character_
  ))

# Data summarization
data1_summary <- data1 %>%
  filter(!is.na(sex), agerange != "n/a") %>%
  group_by(agerange, sex) %>%
  summarise(diagnoses_count = n(), .groups = 'drop')

# Calculate totals for each age group
totals <- data1_summary %>%
  group_by(agerange) %>%
  summarise(total = sum(diagnoses_count), .groups = 'drop')

# Create an interactive ggplot
p <- ggplot(data1_summary, aes(x = agerange, y = diagnoses_count, fill = sex, tooltip = diagnoses_count)) +
  geom_bar_interactive(stat = "identity", position = "stack") +
  scale_fill_manual(values = c("Females" = "#E78AC3", "Males" = "#8DA0CB")) +
  geom_text(data = totals, aes(x = agerange, label = total, y = total + 5), vjust = -0.5, color = "black", inherit.aes = FALSE) +
  labs(
    title = "",
    x = "Age Group",
    y = "# of records",
    fill = ""  # This removes the 'sex' title from the legend
  ) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    axis.text.x = element_text(angle = 0, vjust = 0.5, hjust = 0.5, size = 12)
  )

# Render the interactive chart using girafe (updated function)
girafe(ggobj = p)

```

<br>
<br>

## Sample coverage
```{r RR step123, echo=FALSE, warning=FALSE, out.width = "100%"}
########################################
data1 <- read.csv("data1.csv")  #
data3 <- read.csv("data3.csv")  #
########################################
# Calculate responses
responded_step1 <- sum(!is.na(data1$i4))
responded_step2 <- sum(!is.na(data1[data1$step2chk == 1, 'i4']))
responded_step3 <- sum(!is.na(data3$i4_3))

# Calculate non-responded counts
non_responded_step1 = sample_size - responded_step1
non_responded_step2 = sample_size - responded_step2
non_responded_step3 = sample_size - responded_step3

# Data for stacked horizontal columns with correct assignment of values
column_data <- data.frame(
  step = rep(c("Step 1", "Step 2", "Step 3"), each = 2),
  label = rep(c("Not covered", "Covered"), times = 3),  # Notice the reverse order
  count = c(non_responded_step1, responded_step1, 
            non_responded_step2, responded_step2,
            non_responded_step3, responded_step3)
)

# Reorder 'step' factor to ensure correct step order
column_data$step <- factor(column_data$step, levels = c("Step 1", "Step 2", "Step 3"))

# Ensure 'label' is a factor with 'Covered' coming after 'Not covered' (for reversed stacking order)
column_data$label <- factor(column_data$label, levels = c("Not covered", "Covered"))

# Plot
column_plot <- ggplot(column_data, aes(y = step, x = count, fill = label)) +
  geom_bar(stat = "identity", position = "fill", width = 0.5, color = "grey", 
           aes(fill = label)) +
  scale_fill_manual(values = c("Covered" = "#a8ddb5", "Not covered" = "transparent")) +
  geom_text(aes(label = paste0(count)), 
            position = position_fill(vjust = 0.5), color = "black") +
  ggtitle("Response Rates by Survey Step") +
  scale_y_discrete() +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1)) +
  labs(x = "", y = "", fill = "") +
  theme_minimal() +
  theme(
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 10),
    legend.position = "bottom"
  )

# Display the plot
print(column_plot)
```

<br>
<br>

## Records by cluster
The table below shows the number of records from Step 1 per Cluster. According to sampling strategy for `r country` STEPS survey there should be `r hh_per_cluster` subjects selected in each Cluster. All Clusters in the table with more than `r hh_per_cluster` records will be highlighted in <span style="color: red;">red</span>.
```{r records by cluster, echo=FALSE, message=FALSE, warning=FALSE, out.width = "100%"}

########################################
# Read the data
data1 <- read.csv("data1.csv")
data3 <- read.csv("data3.csv")


# Group by 'i1' and 'i2' and summarize
by_cluster <- group_by(data1, i1, i2)

a <- dplyr::summarize(by_cluster,
                      NrParticipants = n(),
                      PhoneNumberAvailablePercent = round(mean(!is.na(i10)) * 100, 2)
)

# Assume hh_per_cluster is defined or is part of the data
# hh_per_cluster <- some_value_or_calculation

# Sort the data by NrParticipants in descending order
a <- a %>% arrange(desc(NrParticipants))

# Create a datatable with conditional formatting
datatable(a, colnames = c('Region', 'Cluster', 'Nr of records', 'Phone number available (%)')) %>%
  formatStyle(
    'NrParticipants',
    target = 'cell',
    backgroundColor = styleInterval(cuts = hh_per_cluster, values = c('white', 'red'))
  )
```

<br>
<br>

## Records by Device ID
Number of records by Device ID will increase in time. The following Table shows the cumulative nuber of records for Step 1 and Step 2. The number of entries can be changed from the drop down menu and number of records can be sorted by pressing on the sort button on the top.
```{r records by device id, warning=FALSE, echo=FALSE}
########################################
data1 <- read.csv("data1.csv")  #
data3 <- read.csv("data3.csv")  #
########################################

# Prepare summary for data1 (Step1)
by_device_step1 <- data1 %>%
  group_by(device_id) %>%
  summarize(
    NrRecordsStep1 = n(),
    .groups = 'drop'  # To avoid regrouping message
  )

# Prepare summary for data3 (Step3)
by_device_step3 <- data3 %>%
  group_by(device_id_3) %>%
  summarize(
    NrRecordsStep3 = n(),
    .groups = 'drop'  # Drop groups after summarization
  )

# Merge the two summaries to get a single table with both Step1 and Step3 record counts
# Assuming device_id in data1 corresponds to device_id_3 in data3
merged_summary <- by_device_step1 %>%
  full_join(by_device_step3, by = c("device_id" = "device_id_3"))

# Replace NA with 0 using if_else
merged_summary <- merged_summary %>%
  mutate(
    NrRecordsStep1 = if_else(is.na(NrRecordsStep1), 0, NrRecordsStep1),
    NrRecordsStep3 = if_else(is.na(NrRecordsStep3), 0, NrRecordsStep3)
  )

# Render the table using DT::datatable for a better interactive table in RMarkdown or an R notebook
datatable(merged_summary, options = list(pageLength = 10), colnames = c('Device ID', 'Nr of Records Step1', 'Nr of Records Step3'))
```

<br>
<br>

## Records per day by device
In the chart below shows the number of interviews per day for all devices (data collectors). Bubbles will increase in size and change color proportional to number of interviews per day. Bubbles colored in <span style="color: yellow;">yellow</span>, <span style="color: orange;">orange</span> or <span style="color: red;">red</span> will represent cases when data collectors conducted more than 4 interviews, that is usually not possible to achieve during one day.
```{r Records per day per data collector, warning=FALSE, message = FALSE, echo=FALSE, out.width = "100%"}
########################################
data1 <- read.csv("data1.csv")  #
data3 <- read.csv("data3.csv")  #
########################################

# Ensure dates are formatted correctly
data1$i4 <- as.Date(data1$i4)
data1$submission_time <- as.Date(data1$submission_time)

#convert device_id from numeric to string
data1$device_id <- as.character(data1$device_id)

# Get the latest date and the start of the last month
latest_date <- max(data1$submission_time)
oldest_date <- latest_date - 60

# Filter record counts for the last month
record_counts <- data1 %>%
  filter(submission_time >= oldest_date, i4 >= (submission_time - 7)) %>%
  group_by(i4, device_id) %>%
  summarize(record_count = n(), .groups = 'drop')

# Define bullet sizes and custom category text
record_counts <- record_counts %>%
  mutate(
    bullet_size = case_when(
      record_count >= 7 ~ 7,
      record_count == 6 ~ 6,
      record_count == 5 ~ 5,
      record_count == 4 ~ 2,
      record_count == 3 ~ 1.5,
      record_count == 2 ~ 0.7,
      record_count == 1 ~ 0.3
    ),
    # Use category names that describe the data's characteristics
    color_category = case_when(
      record_count == 1~ "1",
      record_count == 2~ "2",
      record_count == 3~ "3",
      record_count == 4~ "4",
      record_count == 5 ~ "5",
      record_count == 6 ~ "6",
      record_count >= 7 ~ "7+"
    )
  )

# Define the ggplot with x-axis label rotation
gg <- ggplot(record_counts, aes(
  x = device_id,
  y = i4,
  size = bullet_size,
  color = color_category,
  text = paste("Device ID:", device_id, "<br># of interviews:", record_count)
)) +
  geom_point() +
  labs(x = "interviews per day:", y = "", title = "") +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)  # Rotates x-axis labels
  ) +
  scale_x_discrete(breaks = unique(record_counts$device_id)) +
  scale_color_manual(
    values = c(
      "1" = "#99d8c9",
      "2" = "#66c2a4",
      "3" = "#41ae76",
      "4" = "#238b45",
      "5" = "yellow",
      "6" = "orange",
      "7+" = "red"
    ),
    labels = c(
      "Low Frequency",
      "Moderate Frequency",
      "High Frequency",
      "Very High Frequency"
    )
  )

# Convert to ggplotly
interactive_plot <- ggplotly(gg, tooltip = "text")

# Adjust legend orientation and x-axis properties
interactive_plot <- interactive_plot %>%
  layout(
    legend = list(
      orientation = "h",
      x = 0.5,
      xanchor = "center",
      y = -0.2, 
      yanchor = "top",
      title = list(text = "") 
    ),
    hovermode = "closest",
    hoverlabel = list(namelength = -1),
    yaxis = list(
      fixedrange = TRUE,
      autorange = "reversed"
    ),
    xaxis = list(
      fixedrange = TRUE
    )
  )

# Display the interactive plot
interactive_plot
```

<br>
<br>

# QR codes
QR codes are used in STEPS survey as unique identifiers and have to be scanned at each step. Data collectors are not supposed to scan the same QR code for two respondents. In case if it happens the records must be corrected immediately on the server side by editing the wrong records. The tables below will show all duplicates for QR codes at the moment for Step 1 and Step 3 separately, if there are any.

## Duplicate QR Codes STEP1

```{r duplicate qr codes data1, warning=FALSE, message = FALSE, echo=FALSE}
########################################
data1 <- read.csv("data1.csv")  #
data3 <- read.csv("data3.csv")  #
########################################

# Drop records with qr=NA
data1 <- data1[!is.na(data1$qr1), ]

# Identifying the QR codes that have duplicates in the dataset
dupl_QR_data1 <- data1$qr1[duplicated(data1$qr1)]

# Initialize an empty data frame to store the results
dupl_ID_data1 <- NULL

# Loop through each unique duplicated QR code
for (qr in unique(dupl_QR_data1)) {
  # Count the number of records for each QR code
  count <- sum(data1$qr1 == qr)
  
  # Create a data frame for each QR, including the device IDs linked with those duplicates
  dupl_ID_data1 <- rbind(data.frame(
    "QR" = qr,
    "Device IDs" = paste(data1$device_id[data1$qr1 == qr], collapse = ", "),
    "Count" = count  # Add the count of records for each QR code
  ), dupl_ID_data1)
}

# Calculate the total count of all duplicates
total_count <- sum(dupl_ID_data1$Count)

# Append a total row to the data frame
dupl_ID_data1 <- rbind(dupl_ID_data1, data.frame(
  QR = "Total",
  "Device IDs" = "",
  Count = total_count
))

# Render the table with kable and add styling
kable_styled <- kable(dupl_ID_data1, format = "html", escape = FALSE, table.attr = 'style="border: 0.25px solid black;"') %>%
  kable_styling(full_width = TRUE, position = "center") %>%
  row_spec(0, background = "#F7F7F7")  # Set the header row color

# Apply alternating row colors and bold to the total row
num_rows <- nrow(dupl_ID_data1)
for (i in 1:num_rows) {
  if (i %% 2 == 0) {
    kable_styled <- row_spec(kable_styled, i, background = "#F0F0F0")
  } else {
    kable_styled <- row_spec(kable_styled, i, background = "#FFFFFF")
  }
}

# Apply bold style to the total row
kable_styled <- row_spec(kable_styled, num_rows, bold = TRUE, background = "#E8E8E8")

kable_styled
```

<br>
<br>

## Duplicate QR Codes STEP3

```{r duplicate qr codes data3, warning=FALSE, message = FALSE, echo=FALSE}
########################################
data1 <- read.csv("data1.csv")  #
data3 <- read.csv("data3.csv")  #
########################################

# Identifying the QR codes that have duplicates in the dataset
dupl_QR_data3 <- data3$qr3[duplicated(data3$qr3)]

# Initialize an empty data frame to store the results
dupl_ID_data3 <- NULL

# Loop through each unique duplicated QR code
for (qr in unique(dupl_QR_data3)) {
  # Count the number of records for each QR code
  count <- sum(data3$qr3 == qr)
  
  # Create a data frame for each QR, including the device IDs linked with those duplicates
  dupl_ID_data3 <- rbind(data.frame(
    "QR" = qr,
    "Device IDs" = paste(data3$device_id[data3$qr3 == qr], collapse = ", "),
    "Count" = count  # Add the count of records for each QR code
  ), dupl_ID_data3)
}

# Calculate the total count of all duplicates
total_count_data3 <- sum(dupl_ID_data3$Count)

# Append a total row to the data frame
dupl_ID_data3 <- rbind(dupl_ID_data3, data.frame(
  QR = "Total",
  "Device IDs" = "",
  Count = total_count_data3
))

# Render the table with kable and add styling
kable_styled <- kable(dupl_ID_data3, format = "html", escape = FALSE, table.attr = 'style="border: 0.25px solid black;"') %>%
  kable_styling(full_width = TRUE, position = "center") %>%
  row_spec(0, background = "#F7F7F7")  # Set the header row color

# Apply alternating row colors and bold to the total row
num_rows <- nrow(dupl_ID_data3)
for (i in 1:num_rows) {
  if (i %% 2 == 0) {
    kable_styled <- row_spec(kable_styled, i, background = "#F0F0F0")
  } else {
    kable_styled <- row_spec(kable_styled, i, background = "#FFFFFF")
  }
}

# Apply bold style to the total row
kable_styled <- row_spec(kable_styled, num_rows, bold = TRUE, background = "#E8E8E8")

kable_styled
```

<br>
<br>

## QR STEP3 ≠ QR STEP1
As mentioned above, the QR codes serve as unique identifiers and are used to match data collected at different steps. Step 3 data is only collected on respondents who participate in Step 1 and the QR codes from Step3 shall match the codes from Step 1. In case if they don't, the list of unmatched codes will appear in the table below.
<br>
<br>
```{r qr codes data3 <> data1, warning=FALSE, message = FALSE, echo=FALSE}
########################################
data1 <- read.csv("data1.csv")  #
data3 <- read.csv("data3.csv")  #
########################################

# Perform an anti_join to find unmatched qr3 values, and calculate counts and device IDs
result_data3 <- data3 %>%
  anti_join(data1, by = c("qr3" = "qr1")) %>%
  group_by(qr3) %>%
  summarise(
    Device_IDs = paste(device_id_3, collapse = ", "),
    Count = n()
  ) %>%
  ungroup()

# Add a row for totals
total_count <- sum(result_data3$Count)
total_row <- data.frame(qr3 = "Total", Device_IDs = "", Count = total_count)
result_data3 <- rbind(result_data3, total_row)

# Create a data frame just for display
result_table <- data.frame(
  QR3 = result_data3$qr3,
  "Device ID" = result_data3$Device_IDs,
  Count = result_data3$Count
)

# Render the table with kable and add styling
kable_styled <- kable(result_table, format = "html", escape = FALSE, table.attr = 'style="border: 0.25px solid black;"') %>%
  kable_styling(full_width = TRUE, position = "center") %>%
  row_spec(0, background = "#F7F7F7")  # Set the header row color

# Apply alternating row colors and bold to the total row
num_rows <- nrow(result_table)
for (i in 1:num_rows) {
  if (i %% 2 == 0) {
    kable_styled <- row_spec(kable_styled, i, background = "#F0F0F0")
  } else {
    kable_styled <- row_spec(kable_styled, i, background = "#FFFFFF")
  }
}

# Apply bold style to the total row
kable_styled <- row_spec(kable_styled, num_rows, bold = TRUE, background = "#E8E8E8")

kable_styled

```

<br>
<br>

## Average HH size
Household listing and selection in STEPS survey is done during the field work and data collectors have to enumerate all eligible household members and then randomly select one. If ennumerators don't list all eligible members that may introduce bias to selection process and have an impact on the survey results.
The bar plot below shows the average number of eligible household members by Device ID. When data collection is conducted in multiple households, the average shall be close to the national estimated average. The <span style="color: green;">green</span> line represents the expected country average that was estimated to be ~ `r country_average_hhsize` members per household. The estimated average can be modified in future reports if needed.
```{r hh size by device id, echo=FALSE, warning=FALSE, out.width = "100%"}
########################################
data1 <- read.csv("data1.csv")  #
data3 <- read.csv("data3.csv")  #
########################################

# Calculate the average household size per device_id
avg_hh_id_per_device <- data1 %>%
  group_by(device_id) %>%
  summarize(avg_hh_id = mean(hh_size, na.rm = TRUE))  # Calculate the mean, ignoring NA values

# Arrange the data in ascending order of average household size
avg_hh_id_per_device <- avg_hh_id_per_device %>%
  arrange(avg_hh_id)  

# Convert 'device_id' to a factor with levels in ascending order of 'avg_hh_id'
avg_hh_id_per_device$device_id <- factor(avg_hh_id_per_device$device_id, 
  levels = avg_hh_id_per_device$device_id)  # Ensures correct order

# Create the bar plot with a horizontal line for the country average household size
ggplot(avg_hh_id_per_device, aes(x = device_id, y = avg_hh_id)) +
  geom_bar(stat = "identity", fill = "skyblue") +  # Bar plot for averages
  geom_text(
    aes(label = round(avg_hh_id, 1)),  # Display the rounded average values as labels
    vjust = -0.5,  # Position the text above the bar
    color = "black",  # Color of the text
    size = 2  # Font size for the labels
  ) +
  geom_hline(
    yintercept = country_average_hhsize,  # Horizontal line for country average
    color = "green",  # Red color for the line
    linetype = "dashed"  # Dashed style
  ) +
  annotate(
    "text",  # Use annotation to add text outside plot areas
    x = 5.5,  # Position horizontally at a suitable location
    y = country_average_hhsize + 0.1,  # Position vertically above the line
    label = "Expected Average",
    color = "black",  # Color to match the line
    size = 2  # Font size
  ) +
  labs(
    title = "",
    x = "Device ID",
    y = "Household Size"
  ) +
  theme_minimal() +  # Minimal theme for better appearance
  theme(
    axis.text.x = element_text(size = 6, angle = 90, hjust = 1),
    axis.text.y = element_text(size = 6)   # Change font size for y-axis text
  )
```

<br>
<br>

# Timing
The duration of the interview is critical for the quality of data collected in the STEPS survey. Interviewers must allocate sufficient time to ensure respondents fully understand the questions and provide accurate answers. The expected interview time can vary depending on the inclusion of optional modules or country-specific questions. If an interview is found to be shorter than the expected duration, those instances must be reviewed and addressed accordingly.

The chart below displays the average interview times for Step 1 and Step 3 per week for the entire survey. We do not expect to see significant weekly variations, particularly a decrease in the average interview time over time.

## Interview time by week
```{r average interview time per week, warning=FALSE, echo=FALSE, out.width = "100%"}
########################################
data1 <- read.csv("data1.csv")  #
data3 <- read.csv("data3.csv")  #
########################################

# Replace values outside the accepted range with NA
data1$step1_time[data1$step1_time < 1 | data1$step1_time > 180] <- NA
data1$step2_time[data1$step2_time < 1 | data1$step2_time > 120] <- NA

# Convert submission time to a POSIXct object and extract the week
data1 <- data1 %>%
  mutate(submission_time = ymd_hms(submission_time)) %>%
  mutate(week = floor_date(submission_time, "week", week_start = 1)) # Get the start of the week

# Ensure correct initialization with weeks starting on Monday
average_times <- data1 %>%
  mutate(
    submission_time = ymd_hms(submission_time),  # Convert to POSIXct
    week = floor_date(submission_time, "week", week_start = 1)  # Start on Monday
  ) %>%
  group_by(week) %>%
  summarize(
    avg_step1_time = round(mean(step1_time, na.rm = TRUE)),  
    avg_step2_time = round(mean(step2_time, na.rm = TRUE))
  )

# Define start and end points for each week
average_times <- average_times %>%
  mutate(
    monday_start = week,  # Monday 0 AM
    monday_end = week + days(7),  # Next Monday 0 AM
    week_range = paste(format(monday_start, "%d %b"), " - ", format(monday_end - days(1), "%d %b"))  # Week range for hover
  )

# Create a plot with segments for each week, named correctly for the legend
combined_plot <- plot_ly() %>%
  add_segments(
    x = average_times$monday_start, 
    xend = average_times$monday_end,
    y = average_times$avg_step1_time,
    yend = average_times$avg_step1_time,
    name = "Step 1",  # Correct name for the legend
    line = list(color = "#66c2a5", width = 8),  # Default color for Step 1
    hovertemplate = paste("Week: %{text} | Average Time: %{y} min"),  # Custom hover text
    text = average_times$week_range  # Pass the week range for hover text
  ) %>%
  add_segments(
    x = average_times$monday_start, 
    xend = average_times$monday_end,
    y = average_times$avg_step2_time,
    yend = average_times$avg_step2_time,
    name = "Step 2",  # Correct name for the legend
    line = list(color = "#abd9e9", width = 8),  # Default color for Step 2
    hovertemplate = paste("%{text} | Average Time: %{y} min"),  # Custom hover text
    text = average_times$week_range  # Pass the week range for hover text
  ) %>%
  layout(
    #title = "Average Interview Time for Step 1 and Step 2 by week",
    xaxis = list(
      title = "Weeks",
      type = "date",
      tickformat = "%d %b",  # Correct date format
      dtick = "M7",  # Align ticks with weeks starting on Monday
      tickvals = average_times$monday_start  # Ensure ticks represent Mondays
    ),
    yaxis = list(title = "Average Time (minutes)"),
    legend = list(orientation = "h", y = -0.2),  # Legend at the bottom
    showlegend = TRUE  # Ensure the legend is displayed
  )

# Display the plot
combined_plot
```

<br>
<br>

The next chart shows the average interview times per Device ID/interviewer. The <span style="color: orange;">orange</span> lines represent the average interview time for all interviewers.

## Average interview time
```{r time by device id, echo=FALSE, warning=FALSE, out.width = "100%"}
########################################
data1 <- read.csv("data1.csv")  #
data3 <- read.csv("data3.csv")  #
########################################

# Replace values outside the accepted range with NA
data1$step1_time[data1$step1_time < 1 | data1$step1_time > 180] <- NA
data1$step2_time[data1$step2_time < 1 | data1$step2_time > 120] <- NA

# Convert `device_id` to a factor
data1$device_id <- as.factor(data1$device_id)

# Group by `device_id` and calculate average times for Step 1 and Step 2
device_avg <- data1 %>%
  group_by(device_id) %>%
  summarize(
    average_step1 = mean(step1_time, na.rm = TRUE),
    average_step2 = mean(step2_time, na.rm = TRUE)
  )

# Determine the y-scale limit for Step 1 and Step 2
y_limit <- max(device_avg$average_step1, na.rm = TRUE) * 1.2  # With a buffer

# Create hover text showing the rounded value in minutes
device_avg$step1_hover <- paste(device_avg$device_id, ": ", round(device_avg$average_step1, 0), "min")
device_avg$step2_hover <- paste(device_avg$device_id, ": ", round(device_avg$average_step2, 0), "min")


# Create a bar graph for Step 1 with a horizontal line at the average time
step1_plot <- ggplot(device_avg, aes(x = device_id, y = average_step1, text = step1_hover, fill = device_id)) +
  geom_bar(stat = "identity") +
  geom_hline(yintercept = mean(device_avg$average_step1, na.rm = TRUE), linetype = "dashed", color = "#fdae61") +
  annotate("text", x = 4, y = y_limit, label = "Step 1", hjust = 0) +
  ylab("Average Time (minutes)") +
  ggtitle("") +
  theme_minimal() +
  scale_fill_manual(values = colorRampPalette(brewer.pal(12, "Set3"))(length(unique(device_avg$device_id)))) +
  ylim(0, y_limit)+  # Ensure common y-scale
  theme(legend.position = "none",
        axis.text.x = element_text(size = 7))  # Set font size for x-axis values

# Create a bar graph for Step 2 with a horizontal line at the average time
step2_plot <- ggplot(device_avg, aes(x = device_id, y = average_step2, text = step2_hover, fill = device_id)) +
  geom_bar(stat = "identity") +
  geom_hline(yintercept = mean(device_avg$average_step2, na.rm = TRUE), linetype = "dashed", color = "#fdae61") +
  annotate("text", x = 4, y = y_limit, label = "Step 2", hjust = 0) +
  ggtitle("") +
  theme_minimal() +
  scale_fill_manual(values = colorRampPalette(brewer.pal(12, "Set3"))(length(unique(device_avg$device_id)))) +
  ylim(0, y_limit)+  # Ensure common y-scale
  theme(legend.position = "none",
        axis.text.x = element_text(size = 7))  # Set font size for x-axis values
# Convert ggplot2 plots to interactive plotly plots with tooltip set to 'text'
step1_plotly <- ggplotly(step1_plot, tooltip = "text")  # Use 'text' for hover
step2_plotly <- ggplotly(step2_plot, tooltip = "text")  # Use 'text' for hover

# Combine the plots in one column using `subplot()` with `plotly`
combined_plot <- subplot(step1_plotly, step2_plotly, nrows = 2, shareX = TRUE, titleX = FALSE)

# Display the combined plot
combined_plot

```

<br>
<br>
Blood pressure measurement is a crucial part of Step 2 data collection and must be conducted according to the recommended procedure. Data collectors are required to measure each participant's blood pressure three times, with at least a 3-minute interval between measurements.

The graph below illustrates the average BP measurement waiting time for each interviewer (Device ID). The size of the bubbles corresponds to the number of interviews conducted. If the average waiting time is less than 3 minutes, the bubbles will appear in <span style="color: red;">red</span>.

## BP average waiting time
```{r average time between bp measurement, echo=FALSE, warning=FALSE, out.width = "100%"}
###############################
data1 <- read.csv("data1.csv")
###############################

# Convert timestamp columns to POSIXct format
data1 <- data1 %>%
  mutate(
    m4a_timestamp = ymd_hms(m4a_timestamp),
    m5a_timestamp = ymd_hms(m5a_timestamp),
    m6a_timestamp = ymd_hms(m6a_timestamp)
  )

# Combine the last two measurements and calculate averages
data1 <- data1 %>%
  mutate(
    interval_1 = as.numeric(difftime(m5a_timestamp, m4a_timestamp, units = "mins")),
    interval_2 = as.numeric(difftime(m6a_timestamp, m5a_timestamp, units = "mins"))
  )

# Replace unplausible times
data1$interval_1[data1$interval_1 < 0 | data1$interval_1 > 15] <- NA
data1$interval_2[data1$interval_2 < 0 | data1$interval_2 > 15] <- NA
# Survey averages
avg_time_between_measurements <- mean(c(data1$interval_1, data1$interval_2), na.rm = TRUE)


# Average time per interviewer and count of records
avg_time_per_interviewer <- data1 %>%
  group_by(device_id) %>%
  summarize(
    avg_interval_1 = mean(interval_1, na.rm = TRUE),
    avg_interval_2 = mean(interval_2, na.rm = TRUE),
    avg_time = mean(c(avg_interval_1, avg_interval_2)),
    record_count = n()  # Count of records per interviewer
  ) %>%
  mutate(
    device_id = as.character(device_id),  # Convert ID to character for easier plotting
    color = ifelse(avg_time < 3, "Under 3 min", "3 min or more")  # Assign labels directly
  )


##################
# Convert to a ggplot object first
p <- ggplot(avg_time_per_interviewer, aes(x = device_id, y = avg_time)) +
  geom_point(aes(size = record_count, color = color, text = paste("ID: ", device_id, "<br>",
                                                                  "Avg Time: ", round(avg_time, 2), " min<br>",
                                                                  "# of Records: ", record_count))) +
  labs(
    title = '',
    x = 'Device ID',
    y = 'Average Time'
  ) +
  scale_color_manual(values = c("Under 3 min" = "#d53e4f", "3 min or more" = "#92c5de")) +
  theme_minimal() +
  theme(
    legend.position = "bottom",  # Ensure the legend moves to the bottom
    axis.text.x = element_text(angle = 90, hjust = 1)  # Rotate labels on the x-axis by 90 degrees
  )

# Make it interactive with plotly
p_interactive <- ggplotly(p, tooltip = "text") %>%
  layout(
    legend = list(
      orientation = "h",
      y = -0.2,
      title = list(text = "")
    )  # Adjust layout to place legend at the bottom and remove title
  )

# Display the interactive plot
p_interactive
```

<br>
<br>

# Frequencies
The recorded dates and months of birth should generally be evenly distributed when computing average numbers. If frequencies for certain dates or months are much higher, this needs to be investigated and addressed. However, it is possible that some respondents may not recall their exact date or month of birth, which could result in higher frequencies for specific dates or months.

## Birth Date and Month Frequencies
```{r frequency of dob, echo=FALSE, warning=FALSE, out.width = "100%"}
###############################
data1 <- read.csv("data1.csv")
###############################

# Data cleaning: setting invalid day and month values to NA
data1$c2a[data1$c2a < 1 | data1$c2a > 31] <- NA
data1$c2b[data1$c2b < 1 | data1$c2b > 12] <- NA

# Birth date frequency
date_table <- table(data1$c2a)
date_df <- as.data.frame(date_table)
names(date_df) <- c("Date", "Frequency")

# Plot for Birth date frequency
p1 <- plot_ly(data = date_df, x = ~Date, y = ~Frequency, type = 'bar',
              marker = list(color = '#dfc27d'),
              text = ~Frequency,
              hoverinfo = 'text',
              showlegend = FALSE) %>%
  layout(title = "Days",
         titlefont = list(size = 16), 
         titleposition = "top left",
         xaxis = list(title = ""), 
         yaxis = list(title = 'Frequency'))

# Birth month frequency
month_table <- table(data1$c2b)
month_df <- as.data.frame(month_table)
names(month_df) <- c("Month", "Frequency")

# Convert month numeric codes to abbreviations
month_df$Month <- factor(month.abb[month_df$Month], levels = month.abb)

# Sort the month data frame to ensure correct order from Jan to Dec
month_df <- month_df %>% arrange(Month)

# Plot for Birth month frequency
p2 <- plot_ly(data = month_df, x = ~Month, y = ~Frequency, type = 'bar',
              marker = list(color = '#dfc27d'),
              text = ~Frequency,
              hoverinfo = 'text',
              showlegend = FALSE) %>%
  layout(title = "Months",
         titlefont = list(size = 16),
         titleposition = "top left",
         xaxis = list(title = ""), 
         yaxis = list(title = 'Frequency'))

# Combine plots into a single column layout
final_plot <- subplot(p1, p2, nrows = 2, margin = 0.05) %>%
  layout(title = "",
         showlegend = FALSE)  # Ensure legend does not appear
final_plot
```
<br>
<br>

## Frequency of physical measurement results

The STEPS survey, a standardized method for collecting, analyzing, and disseminating data on noncommunicable diseases (NCDs) and their risk factors, benefits significantly from incorporating objective physical measurements. These measurements provide a robust foundation for understanding the prevalence and distribution of NCDs, thereby informing public health policies and interventions. They also enable the detection of subtle trends over time that might be missed with self-reported data alone. It is crucial, however, that physical measurements are conducted in a standardized manner according to the predefined methodology.

The purpose of the graphs below is to highlight any potential issues related to the measurements conducted during Step 2 by data collectors:

- <b>Identification of Outliers:</b> Unusually high or low readings can indicate potential data entry errors or anomalies that need further investigation.
- <b>Visualizing Frequency Distribution:</b> the graphs can detect any unusual patterns or irregularities. For instance, a high frequency of specific values might suggest rounding errors, measurement bias, or the recording of reported values instead of measured ones.
- <b>Detecting Measurement Clusters:</b> Clusters of measurements at certain value levels can indicate that some interviewers might not be following the proper measurement protocols. This clustering needs to be investigated and corrected to ensure accurate data collection.

```{r frequency of numbers, echo=FALSE, warning=FALSE, out.width = "100%"}
###############################
data1 <- read.csv("data1.csv")
###############################

# Replace values outside the accepted range with NA
data1$m4a[data1$m4a < 40 | data1$m4a > 300] <- NA
data1$m5a[data1$m5a < 40 | data1$m5a > 300] <- NA
data1$m6a[data1$m6a < 40 | data1$m6a > 300] <- NA
data1$m4b[data1$m4b < 30 | data1$m4b > 200] <- NA
data1$m5b[data1$m5b < 30 | data1$m5b > 200] <- NA
data1$m6b[data1$m6b < 30 | data1$m6b > 200] <- NA

data1$m11[data1$m11 < 140 | data1$m11 > 200] <- NA
data1$m12[data1$m12 < 20 | data1$m12 > 150] <- NA
data1$m14[data1$m14 < 30 | data1$m14 > 200] <- NA
data1$m15[data1$m15 < 70 | data1$m15 > 150] <- NA

all_sbp <- c(data1$m4a, data1$m5a, data1$m6a)
all_dbp <- c(data1$m4b, data1$m5b, data1$m6b)

# Convert the table to a data frame for plotting SBP
all_sbp_table <- table(all_sbp)  # Frequency table of full numbers
sbp_df <- as.data.frame(all_sbp_table)
names(sbp_df) <- c("Measurement", "Frequency")
sbp_df$Measurement <- as.numeric(as.character(sbp_df$Measurement))

# Create the plotly bar plot with custom hover text
p_sbp <- plot_ly(data = sbp_df, x = ~Measurement, y = ~Frequency, type = 'bar',
                 marker = list(color = '#fdae61'),
                 text = ~paste(Measurement, 'mm HG', '(', Frequency,')'),
                 hoverinfo = 'text') %>%
  layout(title = "Systolic Blood Pressure",
         xaxis = list(title = 'SBP',
                      tickvals = seq(min(sbp_df$Measurement, na.rm = TRUE), 
                                     max(sbp_df$Measurement, na.rm = TRUE), by = 5),
                      ticktext = seq(min(sbp_df$Measurement, na.rm = TRUE), 
                                     max(sbp_df$Measurement, na.rm = TRUE), by = 5)),
         yaxis = list(title = 'Frequency'))
p_sbp

# Convert the table to a data frame for plotting DBP
all_dbp_table <- table(all_dbp)  # Frequency table of full numbers
dbp_df <- as.data.frame(all_dbp_table)
names(dbp_df) <- c("Measurement", "Frequency")
dbp_df$Measurement <- as.numeric(as.character(dbp_df$Measurement))

# Create the plotly bar plot
p_dbp <- plot_ly(data = dbp_df, x = ~Measurement, y = ~Frequency, type = 'bar',
                 marker = list(color = '#e6f598'),
                 text = ~paste(Measurement, 'mm HG', '(', Frequency,')'),
                 hoverinfo = 'text') %>%
  layout(title = "Diastolic Blood Pressure",
         xaxis = list(title = 'DBP',
                      tickvals = seq(min(dbp_df$Measurement, na.rm = TRUE), 
                                     max(dbp_df$Measurement, na.rm = TRUE), by = 5),
                      ticktext = seq(min(dbp_df$Measurement, na.rm = TRUE), 
                                     max(dbp_df$Measurement, na.rm = TRUE), by = 5)),
         yaxis = list(title = 'Frequency'))
p_dbp

# Convert the table to a data frame for plotting Height
all_m11_table <- table(data1$m11)  # Frequency table of full numbers
m11_df <- as.data.frame(all_m11_table)
names(m11_df) <- c("Measurement", "Frequency")
m11_df$Measurement <- as.numeric(as.character(m11_df$Measurement))

# Create the plotly bar plot
p_height <- plot_ly(data = m11_df, x = ~Measurement, y = ~Frequency, type = 'bar',
                    marker = list(color = '#5e4fa2'),
                    text = ~paste(Measurement, 'cm', '(', Frequency,')'),
                    hoverinfo = 'text') %>%
  layout(title = "Height",
         xaxis = list(title = 'Height',
                      tickvals = seq(min(m11_df$Measurement, na.rm = TRUE), 
                                     max(m11_df$Measurement, na.rm = TRUE), by = 5),
                      ticktext = seq(min(m11_df$Measurement, na.rm = TRUE), 
                                     max(m11_df$Measurement, na.rm = TRUE), by = 5)),
         yaxis = list(title = 'Frequency'))
p_height

# Convert the table to a data frame for plotting Weight
all_m12_table <- table(data1$m12)  # Frequency table of full numbers
m12_df <- as.data.frame(all_m12_table)
names(m12_df) <- c("Measurement", "Frequency")
m12_df$Measurement <- as.numeric(as.character(m12_df$Measurement))

# Create the plotly bar plot
p_weight <- plot_ly(data = m12_df, x = ~Measurement, y = ~Frequency, type = 'bar',
                    marker = list(color = '#abdda4'),
                    text = ~paste(Measurement, 'kg', '(', Frequency,')'),
                    hoverinfo = 'text') %>%
  layout(title = "Weight",
         xaxis = list(title = 'Weight',
                      tickvals = seq(min(m12_df$Measurement, na.rm = TRUE), 
                                     max(m12_df$Measurement, na.rm = TRUE), by = 5),
                      ticktext = seq(min(m12_df$Measurement, na.rm = TRUE), 
                                     max(m12_df$Measurement, na.rm = TRUE), by = 5)),
         yaxis = list(title = 'Frequency'))
p_weight

# Convert the table to a data frame for plotting Waist
all_m14_table <- table(data1$m14)  # Frequency table of full numbers
m14_df <- as.data.frame(all_m14_table)
names(m14_df) <- c("Measurement", "Frequency")
m14_df$Measurement <- as.numeric(as.character(m14_df$Measurement))

# Create the plotly bar plot
p_waist <- plot_ly(data = m14_df, x = ~Measurement, y = ~Frequency, type = 'bar',
                   marker = list(color = 'yellow'),
                   text = ~paste(Measurement, 'cm', '(', Frequency,')'),
                   hoverinfo = 'text') %>%
  layout(title = "Waist Circumference",
         xaxis = list(title = 'Waist',
                      tickvals = seq(min(m14_df$Measurement, na.rm = TRUE), 
                                     max(m14_df$Measurement, na.rm = TRUE), by = 5),
                      ticktext = seq(min(m14_df$Measurement, na.rm = TRUE), 
                                     max(m14_df$Measurement, na.rm = TRUE), by = 5)),
         yaxis = list(title = 'Frequency'))
p_waist

# Convert the table to a data frame for plotting Hip
all_m15_table <- table(data1$m15)  # Frequency table of full numbers
m15_df <- as.data.frame(all_m15_table)
names(m15_df) <- c("Measurement", "Frequency")
m15_df$Measurement <- as.numeric(as.character(m15_df$Measurement))

# Create the plotly bar plot
p_hip <- plot_ly(data = m15_df, x = ~Measurement, y = ~Frequency, type = 'bar',
                 marker = list(color = '#3288bd'),
                 text = ~paste(Measurement, 'cm', '(', Frequency,')'),
                 hoverinfo = 'text') %>%
  layout(title = "Hip Circumference",
         xaxis = list(title = 'Hip',
                      tickvals = seq(min(m15_df$Measurement, na.rm = TRUE), 
                                     max(m15_df$Measurement, na.rm = TRUE), by = 5),
                      ticktext = seq(min(m15_df$Measurement, na.rm = TRUE), 
                                     max(m15_df$Measurement, na.rm = TRUE), by = 5)),
         yaxis = list(title = 'Frequency'))
p_hip

```

<br>
<br>

## Last Digits Frequency

The last digits frequency analysis for physical measurements, such as blood pressure height, weight, and other readings, is conducted to evaluate the distribution of the final digit in recorded values. This type of analysis helps identify potential data quality issues, such as rounding errors or systematic biases in the measurement process.

Detection of Rounding Bias:

Uniform Distribution Expectation: In a perfectly unbiased and accurate measurement process, the last digits (0-9) should be uniformly distributed. Each digit should appear with approximately equal frequency.
Rounding Patterns: If certain digits (e.g., 0 or 5) appear more frequently than others, it may indicate that data collectors are rounding values to these digits rather than recording the exact measurements. This can compromise the accuracy of the data.
Quality Control:

The bar plots below will help to:

- <b>Identify anomalies:</b> By examining the last digits, researchers can detect anomalies that suggest deviations from standard measurement protocols. For example, a disproportionate frequency of specific digits may indicate that some data collectors are not following proper procedures or are recording of reported values instead of measured ones.

- <b>Highlight the need for additional training or calibration of devices:</b> Frequent irregularities in last digit distribution can highlight the need for additional training for data collectors or recalibration of measurement devices to ensure accurate readings.

- <b>Ensure reliable and precise measurements:</b> Crucial for the integrity of the data analysis. Ensuring that the last digits are evenly distributed helps maintain the validity of statistical analyses and research conclusions.

- <b>Trust in Findings:</b> Stakeholders, including policymakers and healthcare providers, rely on accurate data to make informed decisions. Demonstrating that data collection processes are robust and free from bias enhances the credibility of the findings.

```{r frequency of last digits, echo=FALSE, warning=FALSE, out.width = "100%"}
###############################
data1 <- read.csv("data1.csv")
###############################

# Replace values outside the accepted range with NA
data1$m4a[data1$m4a < 40 | data1$m4a > 300] <- NA
data1$m5a[data1$m5a < 40 | data1$m5a > 300] <- NA
data1$m6a[data1$m6a < 40 | data1$m6a > 300] <- NA
data1$m4b[data1$m4b < 30 | data1$m4b > 200] <- NA
data1$m5b[data1$m5b < 30 | data1$m5b > 200] <- NA
data1$m6b[data1$m6b < 30 | data1$m6b > 200] <- NA

data1$m11[data1$m11 < 100 | data1$m11 > 270] <- NA
data1$m12[data1$m12 < 20 | data1$m12 > 350] <- NA
data1$m14[data1$m14 < 30 | data1$m14 > 200] <- NA
data1$m15[data1$m15 < 45 | data1$m15 > 300] <- NA

all_sbp <- c(data1$m4a, data1$m5a, data1$m6a)
all_dbp <- c(data1$m4b, data1$m5b, data1$m6b)

## Frequency of Last Digits #############################

par(mar=c(2, 2, 2, 2))
par(mfrow=c(3, 2))

# SBP Frequency of Last Digits
sbp_last_digits <- all_sbp %% 10  # Extracts the last digit of each measurement
sbp_digit_table <- table(sbp_last_digits)  # Creates a frequency table of last digits
barplot(sbp_digit_table, main="SBP", xlab="Last Digit", ylab="Frequency", col = "#fdae61")
# DBP Frequency of Last Digits
dbp_last_digits <- all_dbp %% 10
dbp_digit_table <- table(dbp_last_digits)
barplot(dbp_digit_table, main="DBP", xlab="Last Digit", ylab="Frequency", col = "#e6f598")

# height Frequency of Last Digits
height_last_digits <- as.integer(substring(as.character(data1$m11), nchar(as.character(data1$m11))))
height_digit_table <- table(height_last_digits)
barplot(height_digit_table, main="Height", xlab="Last Digit", ylab="Frequency", col = "#5e4fa2")

# weight Frequency of Last Digits
weight_last_digits <- as.integer(substring(as.character(data1$m12), nchar(as.character(data1$m12)))) 
weight_digit_table <- table(weight_last_digits)
barplot(weight_digit_table, main="Weight", xlab="Last Digit", ylab="Frequency", col = "#abdda4")

# waist circumference Frequency of Last Digits
waist_last_digits <- as.integer(substring(as.character(data1$m14), nchar(as.character(data1$m14))))
waist_digit_table <- table(waist_last_digits)
barplot(waist_digit_table, main="Waist circumference", xlab="Last Digit", ylab="Frequency", col = "yellow")

# hip circumference Frequency of Last Digits
hip_last_digits <- as.integer(substring(as.character(data1$m15), nchar(as.character(data1$m15))))
hip_digit_table <- table(hip_last_digits)
barplot(hip_digit_table, main="Hip circumference", xlab="Last Digit", ylab="Frequency", col = "#3288bd")


# Add main title
mtext("Frequency of Last Digits Across Measurements", side=3, line=1, outer=TRUE, cex=1.5)
# Reset plotting layout to default
par(mfrow = c(1, 1))

## Frequency of Last Digits #############################
```

<br>
<br>

