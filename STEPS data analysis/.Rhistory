)
######
####Applying derivation logic based on derived variables linked to existing variables
cleaned_logic = gsub('\\r|\\n','',logic_exist_vars$logic_exp) # Remove carriage returns and newlines from logic expressions
eval(parse(text = paste0(cleaned_logic, sep = '\n')))# Evaluate and execute the cleaned logic expressions
# Assigning data to indicators where no logical expressions are involved
matrix_without_logexp = indicator_matrix %>% dplyr::filter(has_log_exp == FALSE)# Filter rows without logical expressions
indicators_without_logexp = do.call('c',strsplit(matrix_without_logexp$indicator_var, "[;]"))# Extract indicator variables without logical expressions
vars_without_logexp = do.call('c',strsplit(matrix_without_logexp$logic_condition_var, "[;]"))# Extract variables for logic conditions without logical expressions
# If there are variables without logical expressions, assign them directly in the data
if(!is.null(vars_without_logexp))
{
eval(parse(text = paste0('data$',indicators_without_logexp,'= data$',vars_without_logexp, sep='\n')))
}
# Assigning data to indicators where logical expressions are involved
matrix_with_logexp = indicator_matrix %>% dplyr::filter(has_log_exp == TRUE)
indicators_with_logexp = do.call('c',strsplit(matrix_with_logexp$indicator_var, "[;]"))
vars_with_logexp = do.call('c',strsplit(matrix_with_logexp$logic_condition_var, "[;]"))
# If there are indicators with logical expressions, mutate the data accordingly to derive binary variables with 0/1 assignment
if(!is.null(indicators_with_logexp))
{
eval(parse(text = paste0('data = data %>% mutate(',indicators_with_logexp,'= ifelse(',vars_with_logexp,',1,0))', sep='\n')))
eval(parse(text=paste0('data$',indicators_with_logexp,'[is.na(data$',indicators_with_logexp,')]=0', sep='\n')))
# Assign NA to variables with all levels being 0
eval(parse(text=paste0('data$',indicators_with_logexp,'[all(data$',indicators_with_logexp,' == 0)]=NA', sep='\n')))
}
################################################
# Reading an XML file for level information and filtering out unnecessary rows
level_xml_file = read_excel(paste0('data_input/',grep('xml_file.xls',input_files,v=T)),'choices') %>%
dplyr::filter(!is.na(`list name`) & `list name`!='yn' &
`list name`!='yndk' & `list name`!='yndkr' &
`list name`!='ynr' & `list name`!='yndrr' &
`list name`!='yndw' & `list name`!='time_dd' &
`list name`!='time_mm' & `list name`!='time_yyyy' &
`list name`!='psu' & `list name`!='ssu' & `list name`!='tsu' &
name!=77 & name!=88)
# Converting column names of level_xml_file to lowercase
colnames(level_xml_file)=tolower(colnames(level_xml_file))
# Selecting relevant columns from level_xml_file
level_xml_file = level_xml_file %>% dplyr::select(all_of(c("list name",'name',paste0("label::",language))))
###mapping of variables
# Extracting unique variable names from the level XML file
extracted_variables = unique(level_xml_file$`list name`)
# Reading another sheet from the XML file for survey details
original_xml_file = read_excel(paste0('data_input/',grep('xml_file.xls',input_files,v=T)),'survey') %>% dplyr::filter(!is.na(name)) %>% mutate(name = tolower(name))
i = NULL
matched_variables = data.frame()
# Loop through extracted variables to find matching survey variables
for (i in extracted_variables)
{
#unique_var = i
guide_var = unique(grep(paste0('^select_one\\s',i,'$'), original_xml_file$type, v=T))# Find matching guide variables
if (length(guide_var)>0)
{
match_var = (original_xml_file %>% dplyr::filter(type == guide_var) %>% dplyr::select(name))$name # Get matched variables
matched_variables = rbind(matched_variables, cbind(i,match_var))# Combine extracted and matched variables
} else{}
}
# Renaming columns of matched_variables data frame
colnames(matched_variables) = c('level_var','matched_var')
# Removing '_3' suffix from matched variables
matched_variables$matched_var = gsub('_3','', matched_variables$matched_var)
# Checking if matched variables exist in the data
existing_vars_dataset = unique(intersect(matched_variables$matched_var, names(data)))
# Retaining original demographic variables in the dataset
eval(parse(text=paste0('data$demog_',existing_vars_dataset,'=data$',existing_vars_dataset, sep='\n')))
##
i = NULL
# Loop through existing variables dataset to adjust factor levels based on XML file
for(i in  existing_vars_dataset) ###unique(matched_variables$matched_var)
{
sel_level_var = (matched_variables %>% dplyr::filter(matched_var == i) %>% dplyr::select(level_var))$level_var# Get level variable
var_attrs = level_xml_file %>%dplyr::filter(`list name` == sel_level_var)# Get variable attributes
eval(parse(text = paste0('data$demog_',i,' = factor(data$demog_',i,', levels = c(',
paste0('"',var_attrs$name,'"', collapse = ','),'), labels = c(',
paste0('"',eval(parse(text = paste0('var_attrs$`label::',language,'`'))),'"', collapse = ',') ,'))')))
}
# Convert the data frame to a data frame and adjust factor levels
data = data %>% as.data.frame() %>% mutate(sex = factor(c1, levels=1:2, labels=c('Men','Women')),
agerange = factor(agerange, levels=names(table(data[,'agerange'])), labels=names(table(data[,'agerange']))))
# Copying the cleaned data to analysis_data for further analysis
analysis_data = data
####Adjusting col_strat_variable and row_strat_variables objects
i= NULL
adj_col_strat_variable=NULL
# Loop through column stratification variables and adjust based on matched variables
for(i in col_strat_variable)
{
var_match = grep(i, matched_variables$matched_var, v=T)# Find matched variables
if(length(var_match)>0)
{
adj_col_strat_variable = c(adj_col_strat_variable, paste0('demog_',var_match))# Adjust column stratification variables
} else {adj_col_strat_variable = c(adj_col_strat_variable, i)}# Keep original if no match
}
# Adjusting row stratification variables
i= NULL
adj_row_strat_variable=NULL
# Loop through row stratification variables and adjust based on matched variables
for(i in row_strat_variables)
{
var_match = grep(i, matched_variables$matched_var, v=T)# Find matched variables
if(length(var_match)>0)
{
adj_row_strat_variable = c(adj_row_strat_variable, paste0('demog_',var_match))# Adjust row stratification variables
} else {adj_row_strat_variable = c(adj_row_strat_variable, i)}# Keep original if no match
}
# Updating column and row stratification variables with adjusted ones
col_strat_variable = adj_col_strat_variable
row_strat_variables = adj_row_strat_variable
# Reading and processing another sheet from the Excel file for language translations
other_language = read_excel(paste0('data_input/',grep('input_matrix.xls',input_files,v=T)),sheet = 'other')%>%as.data.frame()
colnames(other_language)=tolower(colnames(other_language))
other_language = other_language[,c('item',language)]
# Rewriting translations for 'sex'
other_language[1,2] = levels(data$demog_c1)[1]
other_language[2,2] = levels(data$demog_c1)[2]
####################################Editing the indicator matrix to drop indicators with NA##########################################
indicator_matrix$excl_missing_ind = 'no'
###
indicator_matrix = indicator_matrix %>% mutate(ind_reduce = search_vars(logic_denom = concat_var, nonexist_vars = none_exist_var),
excl_missing_ind = ifelse(ind_reduce == TRUE,'yes',excl_missing_ind),
type = paste0(rep(type,n_semicolons),collapse = ';'))
###
indicator_matrix = indicator_matrix %>% rowwise %>%
mutate(
# Create a column 'var_missing' where each row contains a list of logical values indicating if each variable in 'indicator_var' is missing in 'data'
var_missing = list(eval(parse(text=paste0('c(',paste0('all(is.na(data$',do.call('c',strsplit(indicator_var, "[;]")),'))', collapse = ','),')')))),
##
rev_popsubset = gsub('^all$','TRUE',pop_subset),
rev_popsubset = gsub(';all',';TRUE',rev_popsubset),
rev_popsubset = gsub('all;','TRUE;',rev_popsubset),
pop_missing = list(eval(parse(text=paste0('c(',paste0('with(data, !any(',do.call('c',strsplit(rev_popsubset, "[;]")),',na.rm=T))', collapse = ','),')')))),
#
rev_var_missing = list(eval(parse(text=paste0('c(',paste0(unlist(var_missing),'|',unlist(pop_missing), collapse = ','),')')))),
###
pos_true = paste0(as.character(list(grep('TRUE',rev_var_missing))), collapse = ','),
pos_true = ifelse(pos_true=='integer(0)'|excl_missing_ind == 'no','999',pos_true),
###updated n_semicolons
leng_remove = eval(parse(text=paste0('length(',pos_true,')'))),
rev_n_semicolons = ifelse(pos_true>1 & pos_true!=999, n_semicolons - leng_remove,n_semicolons),
####indicator_var
indicator_var = as.character(list(if(n_semicolons==1 ) {
eval(parse(text = paste0('"',strsplit(indicator_var, "[;]"),'"[-c(',pos_true,')]')))
}else{eval(parse(text = paste0(strsplit(indicator_var, "[;]"),'[-c(',pos_true,')]')))})),
len_ind_var = ifelse(((n_semicolons==1|rev_n_semicolons==1) &  pos_true!='999') |((n_semicolons==1||rev_n_semicolons==1) &  pos_true=='999'),1,length(eval(parse(text = indicator_var)))),
#var_missing = as.character(unlist(var_missing)),
len_ind_var = ifelse(n_semicolons==1 & rev_n_semicolons==1 & pos_true!=999,0,len_ind_var)#,pos_true = as.numeric(pos_true)
)%>%dplyr::filter(len_ind_var>0)
#########
indicator_matrix = indicator_matrix %>% rowwise %>% mutate(
indicator_var = list(if(len_ind_var==1 ){as.character(indicator_var)}else{paste0(eval(parse(text = as.character(indicator_var))), collapse = ';')}),
####logic_condition_var
logic_condition_var = as.character(list(if(n_semicolons==1) {
eval(parse(text = paste0('"',strsplit(logic_condition_var, "[;]"),'"[-c(',pos_true,')]')))
}else{eval(parse(text = paste0(strsplit(logic_condition_var, "[;]"),'[-c(',pos_true,')]')))})),
logic_condition_var = list(if(len_ind_var==1 ){as.character(logic_condition_var)}else{paste0(eval(parse(text = as.character(logic_condition_var))), collapse = ';')}),
####pop_subset
pop_subset = as.character(list(if(n_semicolons==1) {
eval(parse(text = paste0('"',strsplit(pop_subset, "[;]"),'"[-c(',pos_true,')]')))
}else{eval(parse(text = paste0(strsplit(pop_subset, "[;]"),'[-c(',pos_true,')]')))})),
pop_subset = list(if(len_ind_var==1 ){as.character(pop_subset)}else{paste0(eval(parse(text = as.character(pop_subset))), collapse = ';')}),
#####subtitle1
subtitle1 = as.character(list(if(n_semicolons==1) {
as.character(subtitle1)
}else if (!is.na(subtitle2)){
subtitle1
}else{eval(parse(text = as.character(strsplit(subtitle1, "[;]"))))[eval(parse(text = paste0('-c(',pos_true,')')))]})),
subtitle1 = list(if(len_ind_var==1 & is.na(subtitle2)){as.character(subtitle1)}
else if (!is.na(subtitle2)){
subtitle1
}else{paste0(eval(parse(text = as.character(subtitle1))), collapse = ';')}),
# ###subtitle2
subtitle2 = as.character(list(if(n_semicolons==1) {
as.character(subtitle2)
}else{eval(parse(text = paste0(strsplit(as.character(subtitle2), "[;]"),'[-c(',pos_true,')]')))})),
subtitle2 = list(if(len_ind_var==1 ){as.character(subtitle2)}else{paste0(eval(parse(text = as.character(subtitle2))), collapse = ';')}),
# #####type
type = as.character(list(if(n_semicolons==1) {
eval(parse(text = paste0('"',strsplit(as.character(type), "[;]"),'"[-c(',pos_true,')]')))
}else{eval(parse(text = paste0(strsplit(as.character(type), "[;]"),'[-c(',pos_true,')]')))})),
type = list(if(len_ind_var==1 ){as.character(type)}else{paste0(eval(parse(text = as.character(type))), collapse = ';')}),
####Variable types
indicator_var = as.character(indicator_var),
logic_condition_var = as.character(logic_condition_var),
pop_subset = as.character(pop_subset),
subtitle1 = ifelse(!is.null(subtitle1[[1]]),as.character(subtitle1),NA),
subtitle1 = ifelse(subtitle1=="logical(0)"|subtitle1=="NA"|is.na(subtitle1), NA,subtitle1),
subtitle2 = as.character(subtitle2),
subtitle2 = ifelse(subtitle2=="logical(0)"|subtitle2=="NA"|is.na(subtitle1), NA,subtitle2),
subtitle1 = as.character(subtitle1),subtitle2 = as.character(subtitle2),
type = as.character(type) )
#####
indicator_matrix = indicator_matrix %>% mutate(column_strat = tolower(column_strat))
##################
#################Generating data processing report
existence_ISO_rep = ifelse(ISO_existence,paste0('ISO code for ',country,' exists'),paste0('ISO code for ',country,' does not exist hence cvd risk has not been adjusted'))
non_exisiting_group_vars = ifelse(length(none_exist_var)>0,
paste0('The following variables are not in the dataset and have been generated and set to missing as they are required as part of the grouped variables required for derivation of secondary variables: ',
paste0(none_exist_var,collapse = ',')),'All required grouped variables are available')
vars_in_xml_not_dataset = ifelse(length(vars_not_indataset)>0,
paste0('The following variables are in the xls form and not in the dataset: ',
paste0(vars_not_indataset,collapse = ',')),'Variables match between the xls form and the dataset')
resp_77_88  = ifelse(length(vars_with_77_or_88)>0,
paste0('The following variables were assigned either 77 or 88 for dont knows or refusals and these have been set to missing: ',
paste0(vars_with_77_or_88,collapse = ',')),'No variable has been assigned either 77 or 88 for dont knows or refusals in the dataset')
sec_derivarion  = ifelse(length(list_nonexist_dervars)>0,
paste0('The following secondary variables were part of the secondary variables to be derived although the primary variables required for their derivation are partially available: ',
paste0(list_nonexist_dervars,collapse = ',')),'Primary variables are available to derive the secondary variables')
status_execution = ifelse(ISO_existence,'Script execution progressed','The supplied ISO code does not exist in the reference dataset for cvd calculation')
data_processing_report = cbind(Item = c('Existence of ISO code','Completeness of grouped variables','Variables in xls vs dataset','Variables with values set to NA if has 77 or 88 as values',
'Secondary variables without primary variables for derivation','Excecution status'),
Description = c(existence_ISO_rep,non_exisiting_group_vars,vars_in_xml_not_dataset,resp_77_88,sec_derivarion,status_execution))
#########################
flex_processing_report = data_processing_report %>% as.data.frame() %>% flextable()%>%
flextable::style(pr_t=fp_text(font.family='Source Sans Pro'), part = 'all')%>%
bold(part = 'header')%>%
fontsize(size = 9 ,part = "all")%>%autofit()%>%
align(j = 2, align = 'center', part = 'header') %>% theme_vanilla()
## Printing of Codebook::::
doc = read_docx(paste0(getwd(),'/templates/data_processing_template.docx'))
#
doc = headers_replace_text_at_bkm(doc,"country",paste0(toupper(country),' ',survey_year))
#
doc=doc %>% cursor_bookmark(id  = "table1") %>%
body_add_flextable(width(flex_processing_report, width = dim(flex_processing_report)$widths*6.5/(flextable_dim(flex_processing_report)$widths)), pos = "on", align = 'left')
print(doc,target=paste0(getwd(),'/outputs/Data processing report.docx'))
#####Stopping script execution if ISO code is missing
if(!ISO_existence)stop('The supplied ISO code does not exist in the reference dataset for cvd calculation')
####clearing Temp_Tables folder
unlink(paste0(getwd(),'/Temp_Tables/*'))
# clearing Tables folder
files_to_remove = setdiff(list.files(paste0(getwd(),'/Tables')),'Part1.docx')
eval(parse(text = paste0('file.remove("',getwd(),'/Tables/',files_to_remove,'")', sep='\n')))
i=unique(indicator_matrix$section)[1]
data = analysis_data
section_matrix = indicator_matrix %>% dplyr::filter(section == i)
wt_step = unique(section_matrix$weight_step)
data[,wt_step] = as.numeric(as.character(data[,wt_step]))
data = data %>% dplyr::filter(!is.na(get(wt_step)))
svy_data = svydesign(id=~psu, weights=~get(wt_step),strata=~stratum, data=data,nest = T)
output_table = list()
unique(section_matrix$indicator_short_desc)
j=unique(section_matrix$indicator_short_desc)[2]
j
pre_sub_matrix = indicator_matrix %>% dplyr::filter(indicator_short_desc == j)
sub_row=1
sub_matrix = pre_sub_matrix[sub_row,]
subset_indicators = do.call('c',strsplit(sub_matrix$indicator_var, "[;]"))
type_indicators = do.call('c',strsplit(sub_matrix$type, "[;]"))
denom_logic = do.call('c',strsplit(sub_matrix$pop_subset, "[;]"))
#median_compute = sub_matrix$median_computation =='yes' & !is.na(sub_matrix$median_computation)
median_compute = unique(type_indicators)=='median'
###population level indicators
if(is.na(sub_matrix$pop_level_num_denom))
{
pop_num_denom = NA
}else{pop_num_denom = do.call('c',strsplit(sub_matrix$pop_level_num_denom, "[;]"))}
#checking if the indicators are to be combined in the same table
similarity_ind = unique(gsub("\\d{1,2}$", "", na.omit(subset_indicators[1:9])))
##Flag for combining outputs
combine_ind = length(similarity_ind)==1 & length(subset_indicators)>1
col_strat_var_levels
adj_row_strat_variable
col_strat_variable
row_strat_variables
if(i == "Demographic"){col_strat_var_levels = names(table(data[,'demog_c1']))} else{col_strat_var_levels = names(table(data[,col_strat_variable]))}
col_strat_var_levels
paste0('sublist_', 1:length(col_strat_var_levels),'= list()', sep='\n')
subset_indicators
type_indicators[which(subset_indicators %in%k)]
subset_indicators
"dem1b1"->k
type_indicators[which(subset_indicators %in%k)]
data[,k] = as.numeric(data[,k])
i =="Demographic"
denom_logic[which(subset_indicators %in%k)]
datum = data%>%dplyr::filter(!is.na(agerange) & !is.na(eval(parse(text = k))))
k
datum = data%>%dplyr::filter(!is.na(agerange) & !is.na(eval(parse(text = k)))) ###Possible to drop !is.na(agerange) &
row_strat_variables
list_demog_vars = c("agerange", setdiff(row_strat_variables,"agerange"))
list_demog_vars
setdiff(row_strat_variables,"agerange")
list_demog_vars = c("agerange", setdiff(row_strat_variables,"agerange"))
list_demog_vars
row_strat_variables
strat_variable = 'agerange'
datum %>%
# Group by the stratification variable and sex, and calculate counts and means
group_by(eval(parse(text=strat_variable)), sex,.drop = FALSE) %>%
summarise(count = n(), # Count of observations
mean_var = round(mean(eval(parse(text = k)), na.rm = TRUE),1)) %>%# Mean of the variable (rounded to 1 decimal place)
pivot_wider(names_from = sex, values_from = c(count, mean_var))
strat_variable
k
demog_numeric = function(strat_variable = 'agerange')
{
# Create a summary table by grouping data based on the specified stratification variable and sex
summary_table = datum %>%
# Group by the stratification variable and sex, and calculate counts and means
group_by(eval(parse(text=strat_variable)), sex,.drop = FALSE) %>%
summarise(count = n(), # Count of observations
mean_var = round(mean(eval(parse(text = k)), na.rm = TRUE),1)) %>%# Mean of the variable (rounded to 1 decimal place)
pivot_wider(names_from = sex, values_from = c(count, mean_var)) %>%    # Reshape data to wide format, with separate columns for counts and means by sex
# Handle missing values and calculate total counts
mutate(
across(contains(c("Men", "Women")), ~coalesce(., 0)),# Replace NA values with 0 for counts
Total_Count = rowSums(across(contains(c("count_Men", "count_Women")), as.numeric), na.rm = TRUE) # Total count of observations
) %>%
ungroup() %>%
left_join(# Join with data aggregated by stratification variable to get total mean values
datum %>%
group_by(eval(parse(text=strat_variable))) %>%
summarise(Total_mean = round(mean(eval(parse(text = k)), na.rm = TRUE),1))
) %>% full_join(    # Join with overall data aggregated by sex to get overall totals
datum %>%
group_by(sex) %>%
summarise(count = n(), # Overall count of observations by sex
mean_var = round(mean(eval(parse(text = k)), na.rm = TRUE),1)) %>% # Overall mean by sex
pivot_wider(names_from = sex, values_from = c(count, mean_var)) %>%
mutate(agerange = 'Total') %>% # Add a row for total counts
add_column(datum %>% summarise(Total_Count = n(),  # Overall total count
Total_mean=round(mean(eval(parse(text = k)), na.rm=T),1))))# Overall mean
# Define the columns to select for the final summary table
names_to_select = c("eval(parse(text = strat_variable))",'count_Men','mean_var_Men','count_Women','mean_var_Women','Total_Count', 'Total_mean')
# Select the columns from the summary table
summary_table = summary_table %>% dplyr::select(all_of(names_to_select))
###Editing summary_table
summary_table = summary_table %>% dplyr::mutate(
# Format means with one decimal place
mean_var_Men = formatC(round(mean_var_Men,1),format = "f", digits = 1),
mean_var_Women = formatC(round(mean_var_Women,1),format = "f", digits = 1),
Total_mean = formatC(round(Total_mean,1),format = "f", digits = 1),
# Replace values with '-' if counts are below the denominator limit
mean_var_Men = replace(mean_var_Men,count_Men<denom_limit,'-'),
mean_var_Women = replace(mean_var_Women,count_Women<denom_limit,'-'),
Total_mean = replace(Total_mean,Total_Count<denom_limit,'-')
)
# Adjust summary table if the stratification variable is not 'agerange'
if(strat_variable != 'agerange')
{
strat_position = grep(strat_variable,row_strat_variables)
# Exclude rows with NA in the stratification variable column
summary_table = summary_table %>% dplyr::filter(!is.na(`eval(parse(text = strat_variable))`)) ###Excluding the totals row
# Add a title row for the stratification variable
summary_table = rbind(c(row_strat_variable_titles[strat_position], rep('',ncol(summary_table)-1)),summary_table %>% as.matrix())%>%as.data.frame()
} else{}
return(summary_table)
}
demog_numeric()
strat_variable
k
datum %>%
# Group by the stratification variable and sex, and calculate counts and means
group_by(eval(parse(text=strat_variable)), sex,.drop = FALSE) %>%
summarise(count = n(), # Count of observations
mean_var = round(mean(eval(parse(text = k)), na.rm = TRUE),1))
datum %>%
# Group by the stratification variable and sex, and calculate counts and means
group_by(eval(parse(text=strat_variable)), sex,.drop = FALSE) %>%
summarise(count = n(), # Count of observations
mean_var = round(mean(eval(parse(text = k)), na.rm = TRUE),1)) %>%# Mean of the variable (rounded to 1 decimal place)
pivot_wider(names_from = sex, values_from = c(count, mean_var))
# Create a summary table by grouping data based on the specified stratification variable and sex
summary_table = datum %>%
# Group by the stratification variable and sex, and calculate counts and means
group_by(eval(parse(text=strat_variable)), sex,.drop = FALSE) %>%
summarise(count = n(), # Count of observations
mean_var = round(mean(eval(parse(text = k)), na.rm = TRUE),1)) %>%# Mean of the variable (rounded to 1 decimal place)
pivot_wider(names_from = sex, values_from = c(count, mean_var)) %>%    # Reshape data to wide format, with separate columns for counts and means by sex
# Handle missing values and calculate total counts
mutate(
across(contains(c("Men", "Women")), ~coalesce(., 0)),# Replace NA values with 0 for counts
Total_Count = rowSums(across(contains(c("count_Men", "count_Women")), as.numeric), na.rm = TRUE) # Total count of observations
) %>%
ungroup() %>%
left_join(# Join with data aggregated by stratification variable to get total mean values
datum %>%
group_by(eval(parse(text=strat_variable))) %>%
summarise(Total_mean = round(mean(eval(parse(text = k)), na.rm = TRUE),1))
) %>% full_join(    # Join with overall data aggregated by sex to get overall totals
datum %>%
group_by(sex) %>%
summarise(count = n(), # Overall count of observations by sex
mean_var = round(mean(eval(parse(text = k)), na.rm = TRUE),1)) %>% # Overall mean by sex
pivot_wider(names_from = sex, values_from = c(count, mean_var)) %>%
mutate(agerange = 'Total') %>% # Add a row for total counts
add_column(datum %>% summarise(Total_Count = n(),  # Overall total count
Total_mean=round(mean(eval(parse(text = k)), na.rm=T),1))))# Overall mean
summary_table
# Define the columns to select for the final summary table
names_to_select = c("eval(parse(text = strat_variable))",'count_Men','mean_var_Men','count_Women','mean_var_Women','Total_Count', 'Total_mean')
# Select the columns from the summary table
summary_table = summary_table %>% dplyr::select(all_of(names_to_select))
summary_table
strat_variable='ruralurban'
strat_position = grep(strat_variable,row_strat_variables)
strat_position
summary_table
summary_table = datum %>%
# Group by the stratification variable and sex, and calculate counts and means
group_by(eval(parse(text=strat_variable)), sex,.drop = FALSE) %>%
summarise(count = n(), # Count of observations
mean_var = round(mean(eval(parse(text = k)), na.rm = TRUE),1)) %>%# Mean of the variable (rounded to 1 decimal place)
pivot_wider(names_from = sex, values_from = c(count, mean_var)) %>%    # Reshape data to wide format, with separate columns for counts and means by sex
# Handle missing values and calculate total counts
mutate(
across(contains(c("Men", "Women")), ~coalesce(., 0)),# Replace NA values with 0 for counts
Total_Count = rowSums(across(contains(c("count_Men", "count_Women")), as.numeric), na.rm = TRUE) # Total count of observations
) %>%
ungroup() %>%
left_join(# Join with data aggregated by stratification variable to get total mean values
datum %>%
group_by(eval(parse(text=strat_variable))) %>%
summarise(Total_mean = round(mean(eval(parse(text = k)), na.rm = TRUE),1))
) %>% full_join(    # Join with overall data aggregated by sex to get overall totals
datum %>%
group_by(sex) %>%
summarise(count = n(), # Overall count of observations by sex
mean_var = round(mean(eval(parse(text = k)), na.rm = TRUE),1)) %>% # Overall mean by sex
pivot_wider(names_from = sex, values_from = c(count, mean_var)) %>%
mutate(agerange = 'Total') %>% # Add a row for total counts
add_column(datum %>% summarise(Total_Count = n(),  # Overall total count
Total_mean=round(mean(eval(parse(text = k)), na.rm=T),1))))# Overall mean
# Define the columns to select for the final summary table
names_to_select = c("eval(parse(text = strat_variable))",'count_Men','mean_var_Men','count_Women','mean_var_Women','Total_Count', 'Total_mean')
# Select the columns from the summary table
summary_table = summary_table %>% dplyr::select(all_of(names_to_select))
###Editing summary_table
summary_table = summary_table %>% dplyr::mutate(
# Format means with one decimal place
mean_var_Men = formatC(round(mean_var_Men,1),format = "f", digits = 1),
mean_var_Women = formatC(round(mean_var_Women,1),format = "f", digits = 1),
Total_mean = formatC(round(Total_mean,1),format = "f", digits = 1),
# Replace values with '-' if counts are below the denominator limit
mean_var_Men = replace(mean_var_Men,count_Men<denom_limit,'-'),
mean_var_Women = replace(mean_var_Women,count_Women<denom_limit,'-'),
Total_mean = replace(Total_mean,Total_Count<denom_limit,'-')
)
summary_table
strat_position = grep(strat_variable,row_strat_variables)
# Exclude rows with NA in the stratification variable column
summary_table = summary_table %>% dplyr::filter(!is.na(`eval(parse(text = strat_variable))`)) ###Excluding the totals row
summary_table
summary_table = rbind(c(row_strat_variable_titles[strat_position], rep('',ncol(summary_table)-1)),summary_table %>% as.matrix())%>%as.data.frame()###realign labels with subtitles for appended tables
summary_table
# Define a function to generate a summary table for numeric demographic data
demog_numeric = function(strat_variable = 'agerange')
{
# Create a summary table by grouping data based on the specified stratification variable and sex
summary_table = datum %>%
# Group by the stratification variable and sex, and calculate counts and means
group_by(eval(parse(text=strat_variable)), sex,.drop = FALSE) %>%
summarise(count = n(), # Count of observations
mean_var = round(mean(eval(parse(text = k)), na.rm = TRUE),1)) %>%# Mean of the variable (rounded to 1 decimal place)
pivot_wider(names_from = sex, values_from = c(count, mean_var)) %>%    # Reshape data to wide format, with separate columns for counts and means by sex
# Handle missing values and calculate total counts
mutate(
across(contains(c("Men", "Women")), ~coalesce(., 0)),# Replace NA values with 0 for counts
Total_Count = rowSums(across(contains(c("count_Men", "count_Women")), as.numeric), na.rm = TRUE) # Total count of observations
) %>%
ungroup() %>%
left_join(# Join with data aggregated by stratification variable to get total mean values
datum %>%
group_by(eval(parse(text=strat_variable))) %>%
summarise(Total_mean = round(mean(eval(parse(text = k)), na.rm = TRUE),1))
) %>% full_join(    # Join with overall data aggregated by sex to get overall totals
datum %>%
group_by(sex) %>%
summarise(count = n(), # Overall count of observations by sex
mean_var = round(mean(eval(parse(text = k)), na.rm = TRUE),1)) %>% # Overall mean by sex
pivot_wider(names_from = sex, values_from = c(count, mean_var)) %>%
mutate(agerange = 'Total') %>% # Add a row for total counts
add_column(datum %>% summarise(Total_Count = n(),  # Overall total count
Total_mean=round(mean(eval(parse(text = k)), na.rm=T),1))))# Overall mean
# Define the columns to select for the final summary table
names_to_select = c("eval(parse(text = strat_variable))",'count_Men','mean_var_Men','count_Women','mean_var_Women','Total_Count', 'Total_mean')
# Select the columns from the summary table
summary_table = summary_table %>% dplyr::select(all_of(names_to_select))
###Editing summary_table
summary_table = summary_table %>% dplyr::mutate(
# Format means with one decimal place
mean_var_Men = formatC(round(mean_var_Men,1),format = "f", digits = 1),
mean_var_Women = formatC(round(mean_var_Women,1),format = "f", digits = 1),
Total_mean = formatC(round(Total_mean,1),format = "f", digits = 1),
# Replace values with '-' if counts are below the denominator limit
mean_var_Men = replace(mean_var_Men,count_Men<denom_limit,'-'),
mean_var_Women = replace(mean_var_Women,count_Women<denom_limit,'-'),
Total_mean = replace(Total_mean,Total_Count<denom_limit,'-')
)
# Adjust summary table if the stratification variable is not 'agerange'
if(strat_variable != 'agerange')
{
strat_position = grep(strat_variable,row_strat_variables)
# Exclude rows with NA in the stratification variable column
summary_table = summary_table %>% dplyr::filter(!is.na(`eval(parse(text = strat_variable))`)) ###Excluding the totals row
# Add a title row for the stratification variable
summary_table = rbind(c(row_strat_variable_titles[strat_position], rep('',ncol(summary_table)-1)),summary_table %>% as.matrix())%>%as.data.frame()###realign labels with subtitles for appended tables
} else{}
return(summary_table)
}
#####
list_demog_vars = c("agerange", setdiff(row_strat_variables,"agerange"))
num_demog = NULL
summary_table = NULL
##
for(num_demog in list_demog_vars)
{
summary_table = rbind(summary_table, demog_numeric(num_demog))
}
summary_table
summary(data$age)
